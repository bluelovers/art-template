{"version":3,"sources":["../src/precompile.js"],"names":["path","require","acorn","escodegen","estraverse","sourceMap","mergeSourceMap","compile","defaults","runtimePath","resolve","CONSTS","Compiler","LOCAL_MODULE","getDefaults","setting","imports","bail","cache","debug","sourceRoot","options","name","$extend","convertFilenameNode","node","type","resolvePath","resolveFilename","value","dirname","filename","relativePath","relative","test","raw","getOldSourceMap","mappings","source","file","oldSourceMap","SourceMapGenerator","forEach","mapping","addMapping","toJSON","precompile","Error","code","ast","functions","INCLUDE","EXTEND","isLocalModule","tplImportsPath","fn","toString","parse","locations","extendNode","enter","indexOf","id","params","body","expression","operator","left","OUT","right","argument","remove","callee","replaceNode","arguments","FROM","shift","filenameNode","paramNodes","length","DATA","replace","basename","gen","generate","sourceMapRoot","sourceMapWithCode","newSourceMap","map","sourcesContent","IMPORTS","JSON","stringify","module","exports"],"mappings":"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","file":"precompile.js","sourcesContent":["const path = require('path');\nconst acorn = require('acorn');\nconst escodegen = require('escodegen');\nconst estraverse = require('estraverse');\nconst sourceMap = require('source-map');\nconst mergeSourceMap = require('merge-source-map');\nconst compile = require('./compile');\nconst defaults = require('./defaults');\nconst runtimePath = require.resolve('./runtime');\n\nconst CONSTS = compile.Compiler.CONSTS;\nconst LOCAL_MODULE = /^\\.+\\//;\n\n// 获取默认设置\nconst getDefaults = options => {\n    // new defaults\n    const setting = {\n        imports: runtimePath,\n        bail: true,\n        cache: false,\n        debug: false,\n\n        sourceMap: false,\n        sourceRoot: options.sourceRoot\n    };\n\n    for (let name in options) {\n        setting[name] = options[name];\n    }\n\n    return defaults.$extend(setting);\n};\n\n// 转换外部模板文件引入语句的 filename 参数节点\n// 所有绝对路径都转换成相对路径\nconst convertFilenameNode = (node, options) => {\n    if (node.type === 'Literal') {\n        const resolvePath = options.resolveFilename(node.value, options);\n        const dirname = path.dirname(options.filename);\n        const relativePath = path.relative(dirname, resolvePath);\n\n        if (LOCAL_MODULE.test(relativePath)) {\n            node.value = relativePath;\n        } else {\n            node.value = './' + relativePath;\n        }\n\n        delete node.raw;\n    }\n\n    return node;\n};\n\n// 获取原始渲染函数的 sourceMap\nconst getOldSourceMap = (mappings, { sourceRoot, source, file }) => {\n    const oldSourceMap = new sourceMap.SourceMapGenerator({\n        file,\n        sourceRoot\n    });\n\n    mappings.forEach(mapping => {\n        mapping.source = source;\n        oldSourceMap.addMapping(mapping);\n    });\n\n    return oldSourceMap.toJSON();\n};\n\n/**\n * 预编译模版，将模板编译成 javascript 代码\n * 使用静态分析，将模板内部之间依赖转换成 `require()`\n * @param  {Object}       options  编译选项\n * @return {Object}\n */\nconst precompile = (options = {}) => {\n    if (typeof options.filename !== 'string') {\n        throw Error('template.precompile(): \"options.filename\" required');\n    }\n\n    options = getDefaults(options);\n\n    let code = null;\n    let sourceMap = null;\n    let ast = null;\n    const imports = options.imports;\n    const functions = [CONSTS.INCLUDE, CONSTS.EXTEND];\n\n    if (typeof imports !== 'string') {\n        throw Error(\n            'template.precompile(): \"options.imports\" is a file. Example:\\n' +\n                'options: { imports: require.resolve(\"art-template/lib/runtime\") }\\n'\n        );\n    } else {\n        options.imports = require(imports);\n    }\n\n    const isLocalModule = LOCAL_MODULE.test(imports);\n    const tplImportsPath = isLocalModule\n        ? imports\n        : path.relative(path.dirname(options.filename), imports);\n    const fn = compile(options);\n\n    code = '(' + fn.toString() + ')';\n    ast = acorn.parse(code, {\n        locations: options.sourceMap\n    });\n\n    let extendNode = null;\n    const enter = function(node) {\n        if (node.type === 'VariableDeclarator' && functions.indexOf(node.id.name) !== -1) {\n            // TODO 对变量覆盖进行抛错\n            if (node.id.name === CONSTS.INCLUDE) {\n                node['init'] = {\n                    type: 'FunctionExpression',\n                    params: [\n                        {\n                            type: 'Identifier',\n                            name: 'content'\n                        }\n                    ],\n                    body: {\n                        type: 'BlockStatement',\n                        body: [\n                            {\n                                type: 'ExpressionStatement',\n                                expression: {\n                                    type: 'AssignmentExpression',\n                                    operator: '+=',\n                                    left: {\n                                        type: 'Identifier',\n                                        name: CONSTS.OUT\n                                    },\n                                    right: {\n                                        type: 'Identifier',\n                                        name: 'content'\n                                    }\n                                }\n                            },\n                            {\n                                type: 'ReturnStatement',\n                                argument: {\n                                    type: 'Identifier',\n                                    name: CONSTS.OUT\n                                }\n                            }\n                        ]\n                    }\n                };\n                return node;\n            } else {\n                this.remove();\n            }\n        } else if (\n            node.type === 'CallExpression' &&\n            node.callee.type === 'Identifier' &&\n            functions.indexOf(node.callee.name) !== -1\n        ) {\n            let replaceNode;\n            switch (node.callee.name) {\n                case CONSTS.EXTEND:\n                    extendNode = convertFilenameNode(node.arguments[0], options);\n                    replaceNode = {\n                        type: 'AssignmentExpression',\n                        operator: '=',\n                        left: {\n                            type: 'Identifier',\n                            name: CONSTS.FROM\n                        },\n                        right: {\n                            type: 'Literal',\n                            value: true\n                        }\n                    };\n\n                    break;\n\n                case CONSTS.INCLUDE:\n                    const filename = node.arguments.shift();\n                    const filenameNode =\n                        filename.name === CONSTS.FROM\n                            ? extendNode\n                            : convertFilenameNode(filename, options);\n                    const paramNodes = node.arguments.length\n                        ? node.arguments\n                        : [\n                              {\n                                  type: 'Identifier',\n                                  name: CONSTS.DATA\n                              }\n                          ];\n\n                    replaceNode = node;\n                    replaceNode['arguments'] = [\n                        {\n                            type: 'CallExpression',\n                            callee: {\n                                type: 'CallExpression',\n                                callee: {\n                                    type: 'Identifier',\n                                    name: 'require'\n                                },\n                                arguments: [filenameNode]\n                            },\n                            arguments: paramNodes\n                        }\n                    ];\n\n                    break;\n            }\n\n            return replaceNode;\n        }\n    };\n\n    ast = estraverse.replace(ast, {\n        enter: enter\n    });\n\n    if (options.sourceMap) {\n        const sourceRoot = options.sourceRoot;\n        const source = path.relative(sourceRoot, options.filename);\n        const file = path.basename(source);\n        const gen = escodegen.generate(ast, {\n            sourceMap: source,\n            file: file,\n            sourceMapRoot: sourceRoot,\n            sourceMapWithCode: true\n        });\n        code = gen.code;\n\n        const newSourceMap = gen.map.toJSON();\n        const oldSourceMap = getOldSourceMap(fn.mappings, {\n            sourceRoot,\n            source,\n            file\n        });\n        sourceMap = mergeSourceMap(oldSourceMap, newSourceMap);\n        sourceMap.file = file;\n        sourceMap.sourcesContent = fn.sourcesContent;\n    } else {\n        code = escodegen.generate(ast);\n    }\n\n    code = code.replace(/^\\(|\\)[;\\s]*?$/g, '');\n    code =\n        'var ' +\n        CONSTS.IMPORTS +\n        ' = require(' +\n        JSON.stringify(tplImportsPath) +\n        ');\\n' +\n        'module.exports = ' +\n        code +\n        ';';\n\n    return {\n        code,\n        ast,\n        sourceMap,\n        toString: () => code\n    };\n};\n\nmodule.exports = precompile;\n"]}